

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Overview &mdash; Universal Payload 0.75 alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Payload Image Format" href="../image-format/index.html" />
    <link rel="prev" title="Introduction" href="../introduction/index.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Universal Payload
          

          
          </a>

          
            
            
              <div class="version">
                0.75
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../revision-history.html">Revision History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#bootloaders">Bootloaders</a></li>
<li class="toctree-l2"><a class="reference internal" href="#payloads">Payloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bootloader-interfaces">Bootloader interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#coreboot-payload-interface">Coreboot Payload Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slim-bootloader-sbl-payload-interface">Slim Bootloader (SBL) Payload Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pei-to-dxe-interface">PEI to DXE Interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#os-interfaces">OS interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#os-boot-protocols">OS Boot protocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-interface">Data interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#payload-principle">Payload principle</a></li>
<li class="toctree-l2"><a class="reference internal" href="#security">Security</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../image-format/index.html">Payload Image Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hand-off-state/index.html">Hand-off state</a></li>
<li class="toctree-l1"><a class="reference internal" href="../payload-interfaces/index.html">Payload Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-a/index.html">Appendix A – HOB Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references/references.html">References and Links</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Universal Payload</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Overview</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Most modern platforms rely on system Firmware to initialize the
hardware and launch an Operating System (OS). The system firmware is
responsible for initializing the platform hardware including CPU and
other silicon functional blocks, detecting and initializing the
memory subsystem, boot media initialization and setting up hardware
abstractions for use by the operating systems.</p>
<p>While newer architectural enhancements (e.g. - PCI, PCIe, USB, etc.)
are developed at an industrial scale, there are vendor specific
micro-architectural enhancements that happens at a much faster pace.
Silicon vendors differentiate through these microarchitectural
enhancements and these features are often considered intellectual
property and rely on system specific firmware initialization. The
system firmware thus provides the necessary abstraction and allows a
generic operating system to run on different platform configurations
and technologies without needing any changes to the operating system
itself.</p>
<p>A design methodology of viewing system firmware functionality as made
up of two distinct phases (<strong>initialization</strong> and <strong>OS boot logic</strong>)
is gaining traction resulting in newer implementations of system
firmware. This approach calls for modular phases with an
initialization phase (bootloader) which completes the system
initialization and gets the hardware to a usable state and then a
payload phase. The payload can provide/implement many different
functionalities including media and file system drivers, operating
system boot, diagnostics, etc.</p>
<p>While certain system firmware implementations implement both the
initialization and OS boot logic in a single code base, the
distinction lies in the functionality provided.</p>
<p>This specification is used to describe the interface between the
bootloader phase that initializes the system hardware and the payload
phase. It includes how to pass parameters to payload and parameter
format, payload image format, payload boot mode and stack usage, etc.
The intent for this specification is to provide interoperability
between spec compliant bootloaders and spec compliant payloads.</p>
<img alt="../_images/design.png" src="../_images/design.png" />
</div></blockquote>
<p>Opens: Do we need a wrapper table on existing FV, PE/COFF, ELF?</p>
<p>Yes.</p>
<p>Should we put the wrapper inside the existing payload?</p>
<p>Open.</p>
<div class="section" id="bootloaders">
<h2>Bootloaders<a class="headerlink" href="#bootloaders" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Bootloaders are primarily responsible for initializing the system
hardware including, but not limited to CPU initialization, memory
detection and initialization, initialization of silicon functional
units (IO controllers), bus topology configuration, etc. In addition
to the initialization itself, bootloader is responsible for providing
the system configuration information to the subsequent stages in the
boot process. In addition to proprietary options, there are many open
sourced bootloaders available.</p>
<p><strong>EDKII</strong></p>
<p>EDK II is a modern, feature-rich, cross-platform firmware development
environment for the UEFI and UEFI Platform Initialization (PI)
specifications. EDKII performs both first stage (hardware
initialization) and second stage booting.</p>
<p>Reference implementations for many platforms are also available in
open source under BSD + Patents license.</p>
<p><a class="reference external" href="https://www.tianocore.org/">https://www.tianocore.org/</a></p>
<p><strong>Slim Bootloader</strong></p>
<p>Slim Bootloader is an open source system firmware implementation that
adopts the modular initialization followed by payload launch approach
of system firmware design. Slim Bootloader project provides both the
initialization phases as well as the OsLoader payload, but it also
supports launching of different payloads. Open source Slim Bootloader
uses BSD + Patents License.</p>
<p><a class="reference external" href="https://slimbootloader.github.io/">https://slimbootloader.github.io/</a></p>
<p><strong>coreboot</strong></p>
<p>coreboot is a project to develop open source boot firmware for
various architectures. It follows the design philosophy of minimum
necessary initialization followed by payload. coreboot is released
under GNU’s General Public License (GPL).</p>
<p><a class="reference external" href="https://www.coreboot.org/">https://www.coreboot.org/</a></p>
<p><strong>U-Boot</strong></p>
<p>U-Boot is an open-source, primary boot loader used in embedded
devices. U-Boot performs both first stage (hardware initialization)
and second stage booting. U-boot is released under GNU’s General
Public License (GPL)</p>
<p><a class="reference external" href="https://www.denx.de/wiki/U-Boot/WebHome">https://www.denx.de/wiki/U-Boot/WebHome</a></p>
</div></blockquote>
</div>
<div class="section" id="payloads">
<h2>Payloads<a class="headerlink" href="#payloads" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>After initializing the system hardware, bootloaders launch the
payload modules. Payloads ideally are modular and platform
independent. Payloads depend on the abstract interfaces (scope of
this document) to be platform independent.</p>
<p>While OS boot protocol is one of the main functionalities provided by
payloads, there could be other functionalities (e.g - diagnostics)
that can be enabled by payloads.</p>
<p>From a design point of view, a payload is different from a boot image
based on its relationship with the system firmware. Payloads are
considered part of system firmware and is typically in the flash
while boot images are not considered part of system firmware (not
within the trusted firmware boundary) and is often in a boot media.</p>
<p>Also, as mentioned earlier, while certain system firmware
implementations implement both the initialization and OS boot logic
in a single code base, the distinction lies in the functionality
provided. This leads to use cases where some system firmware
implementations can act as a payload providing OS boot capability
while relying on an underlying bootloader layer for system hardware
initialization. Examples of such payloads include EDKII and Uboot.
Both EDKII and uboot implementations implement both phases of system
firmware functionality and can also be launched as payloads by other
bootloaders.</p>
<p>There are many payloads currently available including EDK2 payload
providing UEFI services, Linux as a payload, uboot payload and other
custom implementations.</p>
<p><strong>EDK II Payload</strong></p>
<p>EDK II DXE and BDS stages can be launched by bootloaders as an UEFI
payload. The EDKII payload provides the required UEFI specification
defined architectural protocols and can launch an UEFI aware OS.</p>
<p><strong>SBL OsLoader</strong></p>
<p>It is SBL payload implementation that supports Linux boot protocol and
can also launch ELF or PE executables. It also supports launching OS
compliant with the MultiBoot specification.</p>
<p><strong>Linux Payload</strong></p>
<p>LinuxBoot is a firmware for modern servers that replaces specific
firmware functionality like the UEFI DXE phase with a Linux kernel
and runtime.</p>
<p><a class="reference external" href="https://www.linuxboot.org/">https://www.linuxboot.org/</a></p>
</div></blockquote>
</div>
<div class="section" id="bootloader-interfaces">
<h2>Bootloader interfaces<a class="headerlink" href="#bootloader-interfaces" title="Permalink to this headline">¶</a></h2>
<div class="section" id="coreboot-payload-interface">
<h3>Coreboot Payload Interface<a class="headerlink" href="#coreboot-payload-interface" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Reference</strong>: <a class="reference external" href="https://www.coreboot.org/API">https://www.coreboot.org/API</a></p>
<p><strong>Reference</strong>: <a class="reference external" href="https://doc.coreboot.org/lib/abi-data-consumption.html">https://doc.coreboot.org/lib/abi-data-consumption.html</a></p>
<p><strong>Reference</strong>:
<a class="reference external" href="https://github.com/tianocore/edk2/blob/master/UefiPayloadPkg/Library/CbParseLib/CbParseLib.c">https://github.com/tianocore/edk2/blob/master/UefiPayloadPkg/Library/CbParseLib/CbParseLib.c</a></p>
<p>coreboot passes information to downstream users (payloads and/or
operating systems) using <strong>coreboot tables</strong>.</p>
<p>The table usually sits in memory around address 0x500. However, some
bootloaders seem to overwrite low memory area, thus destroying the
coreboot table integrity, rendering the table useless. So, the
coreboot tables were moved to the high tables area.</p>
<p>When coreboot tables were moved to high memory, a 40 bytes mini
coreboot table with a single sub table is placed at 0x500/0x530 that
points to the real coreboot table. This is comparable to the ACPI
RSDT or the MP floating table.</p>
<p>Coreboot tables is a series of data records packed back to back and
each encoding both type and size. This is something similar to a UEFI
HOB list. Coreboot tables provide information about</p>
</div></blockquote>
<ul class="simple">
<li><strong>memory map</strong></li>
<li><strong>Graphics Info</strong></li>
<li>Pointers to certain CBMEM structures (<strong>ACPI, SMBIOS</strong>, etc)</li>
</ul>
<blockquote>
<div><p>How to fill the gap with current coreboot and payload requirement?</p>
<p>Use a library in coreboot to convert the new interface.</p>
</div></blockquote>
</div>
<div class="section" id="slim-bootloader-sbl-payload-interface">
<h3>Slim Bootloader (SBL) Payload Interface<a class="headerlink" href="#slim-bootloader-sbl-payload-interface" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Reference</strong>:
<a class="reference external" href="https://slimbootloader.github.io/developer-guides/payload.html">https://slimbootloader.github.io/developer-guides/payload.html</a></p>
<p><strong>Reference</strong>:
<a class="reference external" href="https://uefi.org/sites/default/files/resources/PI_Spec_1_7_final_Jan_2019.pdf">https://uefi.org/sites/default/files/resources/PI_Spec_1_7_final_Jan_2019.pdf</a></p>
<p><strong>Reference</strong>:
<a class="reference external" href="https://github.com/tianocore/edk2/blob/master/UefiPayloadPkg/Library/SblParseLib/SblParseLib.c">https://github.com/tianocore/edk2/blob/master/UefiPayloadPkg/Library/SblParseLib/SblParseLib.c</a></p>
<p>SBL supports ‘loosely coupled payload’ which basically refers to
payloads built independently (no source sharing). SBL builds a series
of data structures called the Hand Off Blocks (HOBs) and provides a
pointer to this HOB List to the payloads. These data structures
conform to the HOB format as described in the Platform Initialization
(PI) Specification.</p>
</div></blockquote>
</div>
<div class="section" id="pei-to-dxe-interface">
<h3>PEI to DXE Interface<a class="headerlink" href="#pei-to-dxe-interface" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Reference</strong>:
<a class="reference external" href="https://uefi.org/sites/default/files/resources/PI_Spec_1_7_final_Jan_2019.pdf">https://uefi.org/sites/default/files/resources/PI_Spec_1_7_final_Jan_2019.pdf</a></p>
<p>PEI must also provide a mechanism for components of DXE and the DXE
Foundation to discover the state of the system when the DXE
Foundation is invoked. Certain aspects of the system state at handoff
are architectural, while other system state information may vary and
hence must be described to DXE components.</p>
<p>The DXE IPL PPI passes the Hand-Off Block (HOB) list from PEI to the
DXE Foundation when it invokes the DXE Foundation. The handoff state
is described in the form of HOBs in the HOB list.</p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Required HOB Type</th>
<th class="head">Usage</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Phase Handoff Information Table
(PHIT) HOB</td>
<td>This HOB is required.</td>
</tr>
<tr class="row-odd"><td>One or more Resource Descriptor
HOB(s) describing physical
system memory</td>
<td>The DXE Foundation will use this
physical system memory for DXE.</td>
</tr>
<tr class="row-even"><td>Boot-strap processor (BSP) Stack
HOB</td>
<td>The DXE Foundation needs to know
the current stack location so
that it can move it if
necessary, based upon its
desired memory address map. This
HOB will be of type
EfiConventionalMemory</td>
</tr>
<tr class="row-odd"><td>One or more Resource Descriptor
HOB(s) describing firmware
devices</td>
<td>The DXE Foundation will place
this into the GCD.</td>
</tr>
<tr class="row-even"><td>One or more Firmware Volume
HOB(s)</td>
<td>The DXE Foundation needs this
information to begin loading
other drivers in the platform.</td>
</tr>
<tr class="row-odd"><td>A Memory Allocation Module HOB</td>
<td>This HOB tells the DXE
Foundation where it is when
allocating memory into the
initial system address map.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="os-interfaces">
<h2>OS interfaces<a class="headerlink" href="#os-interfaces" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>While this specification aims to document the bootloader to payload
interface, the payload to OS interface is briefly discussed just for
the sake of completeness.</div></blockquote>
<div class="section" id="os-boot-protocols">
<h3>OS Boot protocols<a class="headerlink" href="#os-boot-protocols" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>UEFI</strong></p>
<p>UEFI stands for “Unified Extensible Firmware Interface.” The UEFI
Specification defines a new model for the interface between
personal-computer operating systems and platform firmware. The
interface consists of data tables that contain platform-related
information, plus boot and runtime service calls that are available
to the operating system and its loader. Together, these provide a
standard environment for booting an operating system and running
pre-boot applications.</p>
<p><a class="reference external" href="https://uefi.org/specifications">https://uefi.org/specifications</a></p>
<p><strong>Linux Boot Protocol</strong></p>
<p>Linux kernel can itself be a bootable image without needing a
separate OS Loader. The Linux boot protocol defines the requirements
required to launch Linux kernel as a boot target.</p>
<p><a class="reference external" href="https://www.kernel.org/doc/html/latest/x86/boot.html">https://www.kernel.org/doc/html/latest/x86/boot.html</a></p>
<p><strong>Multiboot Protocol</strong></p>
<p>The Multiboot specification is an open standard describing how a boot
loader can load an x86 operating system kernel. The specification
allows any compliant boot-loader implementation to boot any compliant
operating-system kernel. Thus, it allows different operating systems
and boot loaders to work together and interoperate, without the need
for operating system specific boot loaders.</p>
<p><a class="reference external" href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html">https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html</a></p>
</div></blockquote>
</div>
<div class="section" id="data-interface">
<h3>Data interface<a class="headerlink" href="#data-interface" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Modern buses and devices (PCI, PCIe, USB, SATA, etc.) support
software detection, enumeration and configuration, providing true
plug and play capabilities, there still exists some devices that are
not enumerable through software.</p>
<p>Examples:</p>
</div></blockquote>
<ul class="simple">
<li>PCI Host Bridge</li>
<li>GPIO</li>
<li>Serial interfaces like I2C, HS-UART, etc.</li>
<li>Graphics framebuffer</li>
<li>Device Management information including manufacturer name, etc.</li>
</ul>
<blockquote>
<div><p>While it is possible to write platform specific device drivers to
support such devices/interfaces, it is efficient for the platform
specific firmware to provide information to the platform independent
operating system.</p>
<p>There are two data protocols that are used extensively for this
purpose: ACPI and Device Tree.</p>
<p><strong>ACPI</strong></p>
<p>Advanced Configuration and Power Interface (<strong>ACPI</strong>) provides an
open standard that operating systems can use to discover and
configure computer hardware components, to perform power management
by (for example) putting unused components to sleep, and to perform
status monitoring. In October 2013, ACPI Special Interest Group (ACPI
SIG), the original developers of the ACPI standard, agreed to
transfer all assets to the UEFI Forum, in which all future
development will take place.</p>
<p><strong>SMBIOS</strong></p>
<p>System Management BIOS (<strong>SMBIOS</strong>) is the premier standard for
delivering management information via system firmware.</p>
<p><a class="reference external" href="https://uefi.org/specifications">https://uefi.org/specifications</a></p>
<p><a class="reference external" href="https://www.dmtf.org/standards/smbios">https://www.dmtf.org/standards/smbios</a></p>
<p><strong>DEVICE TREE</strong></p>
<p>The devicetree is a data structure for describing hardware. A
devicetree is a tree data structure with nodes that describe the
devices in a system. Each node has property/value pairs that describe
the characteristics of the device being represented.</p>
<p><a class="reference external" href="https://www.devicetree.org/">https://www.devicetree.org/</a></p>
</div></blockquote>
</div>
</div>
<div class="section" id="payload-principle">
<h2>Payload principle<a class="headerlink" href="#payload-principle" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="line-block">
<div class="line">Keep interface as clean and simple as possible.</div>
<div class="line">The payload should encapsulate the boot abstractions for a given
technology, such as UEFI payload or LinuxBoot. The Payload should
vie to be portable to different platform implementations (PI), such
as coreboot, Slim bootloader, or an EDKII style firmware.</div>
<div class="line">The payload should elide strong dependencies on the payload
launching code (e.g., coreboot versus EDKII versus slimboot) and
also avoid board-specific dependencies. The payload behavior should
be parameterized by the data input block.</div>
</div>
<div class="line-block">
<div class="line"><strong>Open</strong><em>: Should Payload return back to bootloader if payload
fail?</em></div>
<div class="line"><em>Answer: No for first generation. No callbacks into payload
launcher.</em></div>
</div>
<p><strong>Open</strong><em>: Do we need callback from payload to bootloader? Avoid it
if possible</em></p>
<div class="line-block">
<div class="line"><strong>Open</strong><em>: How to support SMM for booloader and Payload? Where is
trust boundary.</em></div>
<div class="line"><em>Answer: SMM should be either part of the payload for present
generation Management Mode (MM) PI drivers, but longer term the
EDKII PI independent MM modules should be used. The latter are a
class of SMM drivers (or TrustZone drivers for ARM) that are not
launched via DXE. For coreboot SMM can be loaded from ramstage, the
PI payload launcher, or elided from ramstage and use the portable
MM handlers.</em></div>
<div class="line">If there is an existing standard it will be used (e.g., ACPI table
that is simple to parse).</div>
</div>
</div></blockquote>
</div>
<div class="section" id="security">
<h2>Security<a class="headerlink" href="#security" title="Permalink to this headline">¶</a></h2>
<p>Payload is part of system firmware TCB</p>
<blockquote>
<div><p>Today the payload is provisioned as part of the platform
initialization code. As such, the payload is protected and updated by
the platform manufacturer (PM). The payload should be covered by a
digital signature generated by the PM. The platform owner (PO) should
not be able to update the payload independently of the PM.</p>
<div class="line-block">
<div class="line">The platform initialization (PI) code should be the platform root
of trust for update, measurement, and verification. As such, the PI
code that launches the payload should verify the payload using
payload Hash or using a key to verify its signature. The PI code
should also provide a measurement into a Trusted Platform Module
(TPM) of the payload into a TPM Platform Configuration Register
(e.g., PCR[0]). The payload may continue the measured boot actions
by recording code executed in the payload phase into PCRs (e.g.,
UEFI driver into PCR[2], UEFI OS loader into PCR[4]).</div>
<div class="line"><em>Open: Do we need a capability boot to say if payload
supports/requires measured/verified boot?</em></div>
</div>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../image-format/index.html" class="btn btn-neutral float-right" title="Payload Image Format" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../introduction/index.html" class="btn btn-neutral" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Content on this site is licensed under a Creative Commons Attribution 4.0 International license
      Last updated on Jun 17, 2021.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>